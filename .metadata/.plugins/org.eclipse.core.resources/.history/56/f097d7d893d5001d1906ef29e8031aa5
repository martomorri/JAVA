package poo;

import java.util.Arrays;
import java.util.Date;
import java.util.GregorianCalendar;

public class Uso_Empleado {

	public static void main(String[] args) {
		Jefe jefe_rrhh = new Jefe("Martin", 30000, 2022, 9, 15);
		jefe_rrhh.setIncentivo(5000);
		Empleado[] empleados = new Empleado[4];
		empleados[0] = new Empleado("Luciano", 25000, 2023, 2, 14);
		empleados[1] = new Empleado("Benjamin", 41000, 2003, 8, 25);
		empleados[2] = jefe_rrhh;	//Polimorfismo: principio de sustitucion: usamos un objeto de la subclase cuando se espere un objeto de la superclase
		empleados[3] = new Jefe("Pepe", 27500, 1998, 4, 5);
		
		Jefe jefe_finanzas = (Jefe) empleados[3]; // Para castear o refundir el item 3 del array de empleados
		jefe_finanzas.setIncentivo(100000);
		
		Empleado director_comercial = new Jefe("Mariano", 90000, 2008, 6, 15);
		Comparable ejemplo = new Empleado("Tomas", 75000, 2004, 5, 5);
		
		if (director_comercial instanceof Empleado) System.out.println("Es un jefe");
		if (ejemplo instanceof Empleado) System.out.println("Es un jefe");
		System.out.println();
		System.out.println();
		
		for (Empleado item: empleados) {
			item.subirSueldo(5);
		}
		
		Arrays.sort(empleados);
		
		for (Empleado item: empleados) {
			System.out.print("Nombre: " + item.getNombre() + " ");
			/* La variable item se comporta de una manera u otra dependiendo del contexto:
			 * Si es empleado, utiliza el metodo getSueldo de la clase Empleado, mientras que si es jefe
			 * utiliza el mismo metodo, pero de la clase Jefe
			 * Â¿Pero como se da cuenta Java de que metodo usar? Por el enlazado dinamico:
			 * Java sabe automaticamente a que metodo de la clase padre o subclase debe llamar*/
			System.out.print("Sueldo: " + item.getSueldo() + " ");
			System.out.println("Sueldo: " + item.getFechaContrato());
		}
	}

}

class Empleado implements Comparable {
	private int id;
	private static int idSiguiente = 1;
	private String nombre;
	private double sueldo;
	private Date fecha_alta;
	
	public Empleado(String nombre, double sueldo, int ano, int mes, int dia) {
		this.nombre = nombre;
		this.sueldo = sueldo;
		GregorianCalendar fecha = new GregorianCalendar(ano, mes-1, dia);
		fecha_alta = fecha.getTime();
		id = idSiguiente;
		idSiguiente++;
	}
	
	public Empleado(String nombre) {
		//sobrecarga de constructores
		this(nombre, 30000, 2000, 01, 01);	//llamo al constructor que recibe la cantidad de parametros que se le indican
	}
	
	public String getNombre() {
		return nombre + " Id: " + id;
	}
	
	public double getSueldo() {
		return sueldo;
	}
	
	public Date getFechaContrato() {
		return fecha_alta;
	}
	
	public void subirSueldo(double porcentaje) {
		sueldo += sueldo*porcentaje/100;
	}
	
	public int compareTo(Object o) {
		Empleado e = (Empleado) o;
		if (this.getSueldo() < e.getSueldo()) return -1;
		else if (this.getSueldo() > e.getSueldo()) return 1;
		else return 0;
	}
}

class Jefe extends Empleado {
	private double incentivo;
	
	public Jefe(String nombre, double sueldo, int ano, int mes, int dia) {
		super(nombre, sueldo, ano, mes, dia);
	}
	
	public void setIncentivo(double b) {
		incentivo = b;
	}
	
	public double getSueldo() {
		// para sobreescribir un metodo padre
		return super.getSueldo() + incentivo;
	}
}
